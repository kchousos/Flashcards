# Algorithms

Q: Υπολογιστικό πρόβλημα (formally)
A: Ορισμός ενός επιθυμητού μετασχηματισμού ανάμεσα σε ένα σύνολο δεδομένων εισόδου (input) και σε ένα εξόδου (output). Ορίζει τη μορφή και τους περιορισμούς που πρέπει να ικανοποιούν τα παραπάνω σύνολα.

Q: Πώς λέγεται ο ορισμός ενός επιθυμητού μετασχηματισμού ανάμεσα σε ένα σύνολο δεδομένων εισόδου κι εξόδου;
A: Υπολογιστικό πρόβλημα

Q: Κατηγορίες υπολογιστικών προβλημάτων
A:

1. Απόφασης
2. Βελτιστοποίησης

Q: Υπολογιστικό πρόβλημα απόφασης
A: Εύρεση απάντησης μεταξύ "ΝΑΙ" και "ΟΧΙ"

Q: Υπολογιστικό πρόβλημα εύρεσης απάντησης μεταξύ "ΝΑΙ" και "ΟΧΙ"
A: Υπολογιστικό πρόβλημα απόφασης

Q: Υπολογιστικό πρόβλημα βελτιστοποίησης
A: Εύρεση της βέλτιστης λύσης ενός προβλήματος

Q: Υπολογιστικό πρόβλημα εύρεσης της βέλτιστης λύσης ενός προβλήματος
A: Υπολογιστικό πρόβλημα βελτιστοποίησης

Q: Προβλήματα συνδυαστικής βελτιστοποίησης
A: Υπολογιστικά προβλήματα με πεπερασμένο σύνολο αποδεκτών λύσεων που συμπεριλαμβάνει μία βέλτιστη λύση ανν μία τέτοια λύση υπάρχει

Q: Υπολογιστικά προβλήματα με πεπερασμένο σύνολο αποδεκτών λύσεων που συμπεριλαμβάνει μία βέλτιστη λύση ανν μία τέτοια λύση υπάρχει
A: Προβλήματα συνδυαστικής βελτιστοποίησης

Q: Τρόποι ανάλυσης πολυπλοκότητας αλγορίθμου
A: 
1. Πειραματικά
2. Θεωρητικά

Q: Πειραματική ανάλυση πολυπλοκότητας αλγορίθμου
A: Τεστάρισμα και παρατήρηση μίας υλοποίησής του με βάση διάφορα μεγέθη input

Q: Θεωρητική ανάλυση πολυπλοκότητας αλγορίθμου
A: Μαθηματική απόδειξη για το σε ποια τάξη μεγέθους ανήκει

Q: Κατηγορίες υπολογιστικής πολυπλοκότητας
A: 
1. Χειρότερης περίπτωσης
2. Μέσης περίπτωσης
3. Βέλτιστης περίπτωσης

Q: Υπολογιστική πολυπλοκότητα προβλήματος $\Pi$
A: Η πολυπλοκότητα χειρότερης περίπτωσης του καλύτερου αλγορίθμου που λύνει το πρόβλημα $\Pi$

Q: Πώς εκτιμούμε την υπολογιστική πολυπλοκότητα ενός αλγορίθμου $A$;
A: Έστω $T(n)$ η συνάρτηση χρόνου εκτέλεσης του $A$. Για να εκτιμήσουμε την υπολογιστική πολυπλοκότητά του, εκτιμούμε τη *τάξη μεγέθους* της $T(n)$ **ασυμπτωτικά**

Q: Ακριβή ασυμπτωτική εκτίμηση $\Theta$ (formally)
A: $$f(n) \in \Theta(g(n)) \text{ iff } \exists c_1,c_2,n_0 > 0 : \forall n \geq n_0, c_1g(n) \leq f(n) \leq c_2g(n)$$

Q: Άνω φράγμα $O$ (formally)
A: $$f(n) \in O(g(n)) \text{ iff } \exists c,n_0 > 0 : \forall n \geq n_0, f(n) \leq cg(n)$$

Q: Κάτω φράγμα $\Omega$ (formally)
A: $$f(n) \in \Omega(g(n)) \text{ iff } \exists c,n_0 > 0 : \forall n \geq n_0, cg(n) \leq f(n)$$

Q: Πώς συμβολίζουμε το μη ακριβές άνω φράγμα;
A: $o(g(n))$

Q: Τι συμβολίζει το $o(g(n))$;
A: Το μη ακριβές άνω φράγμα

Q: Πώς συμβολίζουμε το μη ακριβές κάτω φράγμα;
A: $\omega(g(n))$

Q: Τι συμβολίζει το $\omega(g(n))$;
A: Το μη ακριβές κάτω φράγμα

Q: Σύγκριση τελεστών ασυμπτωτικού συμβολισμού
A: $$o(n) \lesssim O(n) \lesssim \Theta(n) \lesssim \Omega(n) \lesssim \omega(n)$$

όπου $\lesssim$ σημαίνει "μικρότερο κατά τάξη μεγέθους"

Q: Θέση Cook-Karp
A: Η κλάση *ευεπίλητων* προβλημάτων ταυτίζεται με τη κλάση $P$

C: Η κλάση *ευεπίλητων* προβλημάτων ταυτίζεται με τη κλάση $P$

— [Cook-Karp]

Q: Abstract Data Type (ADT)
A: Ορισμός τύπου δεδομένων με βάση τη συμπεριφορά και τα χαρακτηριστικά τους

Q: Διαφορά μεταξύ δομών δεδομένων κι abstract data types
A: Τα πρώτα έχουν περιγραφές που αφορούν τον implementer, ενώ τα δεύτερα είναι αφηρημένες αναπαραστάσεις που αφορούν τον χρήστη

Q: Τι πρόβλημα προκύπτει από τη χρήση γραμμικών δομών;
A: Κάποια στιγμή θα συναντήσεις γραμμική πολυπλοκότητα

Q: Προτιμότερες κατηγορίες δομών από γραμμικές
A: 
1. Ιεαρχικές (π.χ. δέντρα, σωρός)
2. Τυχαιότητα (π.χ. hashtable)
