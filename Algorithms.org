* Algorithms

Q: Υπολογιστικό πρόβλημα (formally) 
A: Ορισμός ενός επιθυμητού μετασχηματισμού ανάμεσα σε ένα σύνολο δεδομένων εισόδου (input) και σε ένα εξόδου (output). Ορίζει τη μορφή και τους περιορισμούς που πρέπει να ικανοποιούν τα παραπάνω σύνολα.

Q: Πώς λέγεται ο ορισμός ενός επιθυμητού μετασχηματισμού ανάμεσα σε ένα σύνολο δεδομένων εισόδου κι εξόδου; 
A: Υπολογιστικό πρόβλημα

Q: Κατηγορίες υπολογιστικών προβλημάτων 
A:

1. Απόφασης
2. Βελτιστοποίησης

Q: Υπολογιστικό πρόβλημα απόφασης 
A: Εύρεση απάντησης μεταξύ "ΝΑΙ" και "ΟΧΙ"

Q: Υπολογιστικό πρόβλημα εύρεσης απάντησης μεταξύ "ΝΑΙ" και "ΟΧΙ" 
A: Υπολογιστικό πρόβλημα απόφασης

Q: Υπολογιστικό πρόβλημα βελτιστοποίησης 
A: Εύρεση της βέλτιστης λύσης ενός προβλήματος

Q: Υπολογιστικό πρόβλημα εύρεσης της βέλτιστης λύσης ενός προβλήματος 
A: Υπολογιστικό πρόβλημα βελτιστοποίησης

Q: Προβλήματα συνδυαστικής βελτιστοποίησης 
A: Υπολογιστικά προβλήματα με πεπερασμένο σύνολο αποδεκτών λύσεων που συμπεριλαμβάνει μία βέλτιστη λύση ανν μία τέτοια λύση υπάρχει

Q: Υπολογιστικά προβλήματα με πεπερασμένο σύνολο αποδεκτών λύσεων που συμπεριλαμβάνει μία βέλτιστη λύση ανν μία τέτοια λύση υπάρχει 
A: Προβλήματα συνδυαστικής βελτιστοποίησης

Q: Τρόποι ανάλυσης πολυπλοκότητας αλγορίθμου 
A: 1. Πειραματικά 2. Θεωρητικά

Q: Πειραματική ανάλυση πολυπλοκότητας αλγορίθμου 
A: Τεστάρισμα και παρατήρηση μίας υλοποίησής του με βάση διάφορα μεγέθη input

Q: Θεωρητική ανάλυση πολυπλοκότητας αλγορίθμου 
A: Μαθηματική απόδειξη για το σε ποια τάξη μεγέθους ανήκει

Q: Κατηγορίες υπολογιστικής πολυπλοκότητας 
A: 1. Χειρότερης περίπτωσης 2. Μέσης περίπτωσης 3. Βέλτιστης περίπτωσης

Q: Υπολογιστική πολυπλοκότητα προβλήματος $\Pi$ 
A: Η πολυπλοκότητα χειρότερης περίπτωσης του καλύτερου αλγορίθμου που λύνει το πρόβλημα $\Pi$

Q: Πώς εκτιμούμε την υπολογιστική πολυπλοκότητα ενός αλγορίθμου $A$; 
A: Έστω $T(n)$ η συνάρτηση χρόνου εκτέλεσης του $A$. Για να εκτιμήσουμε την υπολογιστική πολυπλοκότητά του, εκτιμούμε τη /τάξη μεγέθους/ της $T(n)$ *ασυμπτωτικά*

Q: Ακριβή ασυμπτωτική εκτίμηση $\Theta$ (formally) 
A: $$f(n) \in \Theta(g(n)) \text{ iff } \exists c_1,c_2,n_0 > 0 : \forall n \geq n_0, c_1g(n) \leq f(n) \leq c_2g(n)$$

Q: Άνω φράγμα $O$ (formally) 
A: $$f(n) \in O(g(n)) \text{ iff } \exists c,n_0 > 0 : \forall n \geq n_0, f(n) \leq cg(n)$$

Q: Κάτω φράγμα $\Omega$ (formally) 
A: $$f(n) \in \Omega(g(n)) \text{ iff } \exists c,n_0 > 0 : \forall n \geq n_0, cg(n) \leq f(n)$$

Q: Πώς συμβολίζουμε το μη ακριβές άνω φράγμα; 
A: $o(g(n))$

Q: Τι συμβολίζει το $o(g(n))$; 
A: Το μη ακριβές άνω φράγμα

Q: Πώς συμβολίζουμε το μη ακριβές κάτω φράγμα; 
A: $\omega(g(n))$

Q: Τι συμβολίζει το $\omega(g(n))$; 
A: Το μη ακριβές κάτω φράγμα

Q: Σύγκριση τελεστών ασυμπτωτικού συμβολισμού 
A: $$o(n) \lesssim O(n) \lesssim \Theta(n) \lesssim \Omega(n) \lesssim \omega(n)$$

όπου $\lesssim$ σημαίνει "μικρότερο κατά τάξη μεγέθους"

Q: Θέση Cook-Karp 
A: Η κλάση /ευεπίλητων/ προβλημάτων ταυτίζεται με τη κλάση $P$

C: Η κλάση /ευεπίλητων/ προβλημάτων ταυτίζεται με τη κλάση $P$

--- [Cook-Karp]

Q: Abstract Data Type (ADT) 
A: Ορισμός τύπου δεδομένων με βάση τη συμπεριφορά και τα χαρακτηριστικά τους

Q: Διαφορά μεταξύ δομών δεδομένων κι abstract data types 
A: Τα πρώτα έχουν περιγραφές που αφορούν τον implementer, ενώ τα δεύτερα είναι αφηρημένες αναπαραστάσεις που αφορούν τον χρήστη

Q: Τι πρόβλημα προκύπτει από τη χρήση γραμμικών δομών; 
A: Κάποια στιγμή θα συναντήσεις γραμμική πολυπλοκότητα

Q: Προτιμότερες κατηγορίες δομών από γραμμικές 
A: 1. Ιεαρχικές (π.χ. δέντρα, σωρός) 2. Τυχαιότητα (π.χ. hashtable)
